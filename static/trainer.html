<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trainer</title>
<style>
  body{font-family:sans-serif;margin:0}
  header{border-bottom:1px solid #ccc;padding:8px}
  nav a{margin-right:8px}
  main{padding:12px;max-width:1000px;margin:0 auto;display:flex;flex-direction:column;gap:16px}
  .row{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  button{background:transparent;border:1px solid #ccc;padding:6px 12px;cursor:pointer}
  input[type="text"],select{padding:6px;border:1px solid #ccc}
  .muted{color:#555}
  .card{border:1px solid #ccc;padding:12px}
  .q{font-weight:bold}
  .a{margin-top:8px;border-top:1px dashed #ccc;padding-top:8px;white-space:pre-wrap}
  .stats{display:flex;gap:12px}
  .ok{color:#166534}
  .bad{color:#b91c1c}
  .bar{height:8px;background:#eee;border:1px solid #ccc}
  .bar>span{display:block;height:100%;background:#999}
  .center{display:flex;justify-content:center;gap:8px}
  .choices{display:grid;gap:6px;margin-top:8px}
  .choice{display:flex;align-items:center;gap:8px}
  .chip{padding:2px 8px;border:1px solid #ccc;border-radius:999px}
  .pill{padding:2px 8px;border:1px solid #ccc;border-radius:999px}
  .letters{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
  .letter{min-width:28px;text-align:center;border:1px solid #ccc;padding:4px 6px;cursor:pointer}
  .slots{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
  .slot{min-width:28px;text-align:center;border:1px dashed #aaa;padding:4px 6px}
  .hidden{display:none}
  .timer{font-variant-numeric:tabular-nums}

  /* ===== Mobile-Optimierung (≤ 640px) ===== */
@media (max-width: 640px){
  /* Layout & Abstände */
  main{ padding:10px }
  .row{ flex-direction:column; align-items:stretch; gap:10px }
  .bar{ flex-direction:column; align-items:stretch; gap:8px }

  /* Navigation & Buttons: bessere Touch-Ziele */
  nav a{ display:inline-block; padding:10px 12px }
  button{ padding:10px 12px; min-height:44px } /* mind. Apple/Google-Empfehlung */

  /* Formulare: Inputs auf volle Breite */
  input[type="text"],
  input[type="date"],
  input[type="time"],
  select,
  textarea{ width:100% }

  /* Tabellen: horizontal scrollen statt umbrechen */
  table{ display:block; overflow-x:auto; -webkit-overflow-scrolling:touch }
  thead th, tbody td{ white-space:nowrap }

  /* Kalender: volle Breite & größere Zellen für Touch */
  #calendar{ width:100% }
  th, td{ padding:10px 6px }
  td{ min-width:36px; min-height:44px }  /* besser antippbar */
  td.markiert{ border-width:2px; border-radius:8px } /* runde Markierung auch auf kleinen Zellen */

  /* Trainer: Optionen schön einspaltig */
  .choices{ display:grid; grid-template-columns:1fr; gap:8px }
  .letters{ gap:8px }
  .slot, .letter{ min-width:36px; padding:8px } /* bessere Trefferfläche */

  /* Fragen-/Kurs-Tabellen: Aktionen umbrechen */
  .actions button{ margin:4px 2px }
}

</style>
</head>
<body>
<header>
  <nav>
    <a href="main.html">Main</a>
    <a href="kalender.html">Kalender</a>
    <a href="fahrschulfragen.html">Fahrschulfragen</a>
    <a href="trainer.html" aria-current="page">Trainer</a>
  </nav>
</header>

<main>
  <h2>Fahrschulfragen Trainer</h2>

  <div class="row">
    <label>Kurs
      <select id="sel-course"></select>
    </label>
    <label>Thema
      <select id="sel-topic"></select>
    </label>
    <label><input type="checkbox" id="chk-all-topics"> alle Themen</label>
  </div>

  <div class="row">
    <label>Modus
      <select id="sel-mode">
        <option value="card">Karteikarte</option>
        <option value="input">Eingabe</option>
        <option value="mc">Multiple Choice</option>
        <option value="tf">Wahr/Falsch</option>
        <option value="cloze">Lückentext (ein Wort)</option>
        <option value="letters">Buchstaben-Puzzle</option>
      </select>
    </label>
    <label><input type="checkbox" id="chk-shuffle" checked> zufällige Reihenfolge</label>
    <label><input type="checkbox" id="chk-relapse"> falsche am Ende wiederholen</label>
    <label><input type="checkbox" id="chk-normalize" checked> Antworten normalisieren</label>
    <label class="row" style="margin-left:auto">
      <input type="checkbox" id="chk-timer"> Timer
      <input type="number" id="timer-sec" min="5" value="20" style="width:70px"> s
      <span id="timer-left" class="pill timer hidden">—</span>
    </label>
    <button id="btn-start">Start</button>
  </div>

  <div id="panel-empty" class="muted">Bitte Kurs/Thema wählen und auf <strong>Start</strong> klicken.</div>

  <div id="panel-train" hidden>
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="stats">
        <div>Fortschritt: <span id="s-idx">0</span>/<span id="s-total">0</span></div>
        <div class="ok">Richtig: <span id="s-ok">0</span></div>
        <div class="bad">Falsch: <span id="s-bad">0</span></div>
      </div>
      <div class="chip" id="chip-mode">—</div>
    </div>
    <div class="bar"><span id="bar-fill" style="width:0%"></span></div>

    <div class="card">
      <div class="q" id="q-text">—</div>

      <!-- Eingabe-Modus -->
      <div id="mode-input" class="row hidden" style="margin-top:8px;">
        <input type="text" id="answer-in" placeholder="Antwort eingeben…" />
        <button id="btn-check">Prüfen</button>
        <span id="check-msg" class="muted"></span>
      </div>

      <!-- Multiple Choice -->
      <div id="mode-mc" class="hidden">
        <div class="choices" id="mc-choices"></div>
        <div class="row" style="margin-top:8px;">
          <button id="btn-check-mc">Antwort prüfen</button>
          <span id="mc-msg" class="muted"></span>
        </div>
      </div>

      <!-- Wahr/Falsch -->
      <div id="mode-tf" class="hidden">
        <div class="muted" style="margin-top:8px;">Passt die angezeigte Antwort zu dieser Frage?</div>
        <div id="tf-proposed" class="pill" style="margin-top:6px;">—</div>
        <div class="row" style="margin-top:8px;">
          <button id="btn-tf-true">Stimmt</button>
          <button id="btn-tf-false">Stimmt nicht</button>
          <span id="tf-msg" class="muted"></span>
        </div>
      </div>

      <!-- Lückentext (ein Wort) -->
      <div id="mode-cloze" class="hidden">
        <div id="cloze-text" style="margin-top:8px;"></div>
        <div class="row" style="margin-top:8px;">
          <input type="text" id="cloze-in" placeholder="fehlendes Wort…" />
          <button id="btn-cloze-check">Prüfen</button>
          <span id="cloze-msg" class="muted"></span>
        </div>
      </div>

      <!-- Buchstaben-Puzzle -->
      <div id="mode-letters" class="hidden">
        <div class="slots" id="letters-slots"></div>
        <div class="letters" id="letters-bank"></div>
        <div class="row" style="margin-top:8px;">
          <button id="btn-letters-clear">Zurücksetzen</button>
          <button id="btn-letters-check">Prüfen</button>
          <span id="letters-msg" class="muted"></span>
        </div>
      </div>

      <div class="a" id="a-text" hidden></div>
    </div>

    <div class="center" style="margin-top:8px;">
      <button id="btn-show">Antwort anzeigen</button>
      <button id="btn-correct">Richtig</button>
      <button id="btn-wrong">Falsch</button>
      <button id="btn-prev">Zurück</button>
      <button id="btn-next">Weiter</button>
    </div>

    <div class="row" style="justify-content:space-between;margin-top:8px;">
      <button id="btn-restart">Neu starten</button>
    </div>
  </div>
</main>

<script>
const KEY_KURSE="kurse-v1", KEY_THEMEN="themen-v1", KEY_FRAGEN="fragen-v1";
const load=(k,d=[])=>{try{const v=JSON.parse(localStorage.getItem(k));return v??d;}catch{return d;}};
const escapeHtml=s=>String(s).replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));

// UI refs
const selCourse=document.getElementById("sel-course");
const selTopic=document.getElementById("sel-topic");
const chkAll=document.getElementById("chk-all-topics");
const selMode=document.getElementById("sel-mode");
const chkShuffle=document.getElementById("chk-shuffle");
const chkRelapse=document.getElementById("chk-relapse");
const chkNormalize=document.getElementById("chk-normalize");
const chkTimer=document.getElementById("chk-timer");
const timerSec=document.getElementById("timer-sec");
const timerLeft=document.getElementById("timer-left");

const btnStart=document.getElementById("btn-start");
const panelEmpty=document.getElementById("panel-empty");
const panelTrain=document.getElementById("panel-train");

const qText=document.getElementById("q-text");
const aText=document.getElementById("a-text");
const btnShow=document.getElementById("btn-show");
const btnCorrect=document.getElementById("btn-correct");
const btnWrong=document.getElementById("btn-wrong");
const btnPrev=document.getElementById("btn-prev");
const btnNext=document.getElementById("btn-next");

const modeInput=document.getElementById("mode-input");
const ansIn=document.getElementById("answer-in");
const btnCheck=document.getElementById("btn-check");
const checkMsg=document.getElementById("check-msg");

const modeMC=document.getElementById("mode-mc");
const mcChoices=document.getElementById("mc-choices");
const btnCheckMC=document.getElementById("btn-check-mc");
const mcMsg=document.getElementById("mc-msg");

const modeTF=document.getElementById("mode-tf");
const tfProposed=document.getElementById("tf-proposed");
const btnTFTrue=document.getElementById("btn-tf-true");
const btnTFFalse=document.getElementById("btn-tf-false");
const tfMsg=document.getElementById("tf-msg");

const modeCloze=document.getElementById("mode-cloze");
const clozeText=document.getElementById("cloze-text");
const clozeIn=document.getElementById("cloze-in");
const btnClozeCheck=document.getElementById("btn-cloze-check");
const clozeMsg=document.getElementById("cloze-msg");

const modeLetters=document.getElementById("mode-letters");
const lettersSlots=document.getElementById("letters-slots");
const lettersBank=document.getElementById("letters-bank");
const btnLettersClear=document.getElementById("btn-letters-clear");
const btnLettersCheck=document.getElementById("btn-letters-check");
const lettersMsg=document.getElementById("letters-msg");

const sIdx=document.getElementById("s-idx");
const sTot=document.getElementById("s-total");
const sOk=document.getElementById("s-ok");
const sBad=document.getElementById("s-bad");
const barFill=document.getElementById("bar-fill");
const btnRestart=document.getElementById("btn-restart");
const chipMode=document.getElementById("chip-mode");

let QUESTIONS=[], order=[], idx=0, okCount=0, badCount=0, wrongIds=new Set(), timerHandle=null, timeLeft=0;

// helpers
function normalize(str){
  if(!chkNormalize.checked) return String(str||"");
  return String(str||"")
    .toLowerCase()
    .replace(/[.,;:!?()"'`´^°\\/_-]/g,"")
    .replace(/\s+/g,"")
    .trim();
}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}
function getQuery(){const p=new URLSearchParams(location.search);return {course:p.get("course"), topic:p.get("topic"), all:p.get("all")==="1"};}

function fillCourses(){
  const kurse=load(KEY_KURSE);
  selCourse.innerHTML="";
  if(kurse.length===0){selCourse.innerHTML="<option value=''>-- kein Kurs --</option>";return;}
  kurse.forEach(k=>{
    const o=document.createElement("option");o.value=k.id;o.textContent=k.name;selCourse.appendChild(o);
  });
  fillTopics();
}
function fillTopics(){
  const courseId=selCourse.value;
  const topics=load(KEY_THEMEN).filter(t=>t.courseId===courseId);
  selTopic.innerHTML="";
  if(topics.length===0){selTopic.innerHTML="<option value=''>-- kein Thema --</option>";return;}
  topics.forEach(t=>{
    const o=document.createElement("option");o.value=t.id;o.textContent=t.name;selTopic.appendChild(o);
  });
}
selCourse.addEventListener("change",fillTopics);

// session
function startSession(){
  const courseId=selCourse.value;
  const topicId=selTopic.value;
  const allQ=load(KEY_FRAGEN);
  let pool=[];
  if(chkAll.checked){
    const topicIds=load(KEY_THEMEN).filter(t=>t.courseId===courseId).map(t=>t.id);
    pool=allQ.filter(q=>topicIds.includes(q.topicId));
  }else{
    pool=allQ.filter(q=>q.topicId===topicId);
  }
  if(pool.length===0){alert("Keine Fragen gefunden.");return;}
  QUESTIONS=pool.map(q=>({id:q.id,frage:q.frage||"",antwort:q.antwort||""}));
  order=QUESTIONS.map((_,i)=>i);
  if(chkShuffle.checked)shuffle(order);
  idx=0;okCount=0;badCount=0;wrongIds.clear();
  sTot.textContent=QUESTIONS.length;
  panelEmpty.hidden=true;panelTrain.hidden=false;
  applyMode();showCurrent(true);updateStats();
}
btnStart.onclick=startSession;

function applyMode(){
  const mode=selMode.value;
  chipMode.textContent = (
    mode==="card"   ? "Karteikarte" :
    mode==="input"  ? "Eingabe" :
    mode==="mc"     ? "Multiple Choice" :
    mode==="tf"     ? "Wahr/Falsch" :
    mode==="cloze"  ? "Lückentext" :
    "Buchstaben-Puzzle"
  );
  // Sichtbarkeit
  modeInput.classList.toggle("hidden", mode!=="input");
  btnShow.hidden   = (mode!=="card");
  modeMC.classList.toggle("hidden", mode!=="mc");
  modeTF.classList.toggle("hidden", mode!=="tf");
  modeCloze.classList.toggle("hidden", mode!=="cloze");
  modeLetters.classList.toggle("hidden", mode!=="letters");
  // Antwortbox (Karteikarte)
  aText.hidden = mode!=="card";
  if(mode==="card") aText.hidden=true; // erst auf Klick zeigen
}

function currentQ(){ return QUESTIONS[order[idx]]; }

// === Multiple Choice ===
let MC_STATE={selected:null, options:[]};
function uniqueNonEmpty(arr){
  const s=new Set();const out=[];
  arr.forEach(x=>{
    const k=normalize(x);
    if(k && !s.has(k)){ s.add(k); out.push(x); }
  });
  return out;
}
function makeMCOptions(correct, poolAnswers){
  const uniq = uniqueNonEmpty(poolAnswers);
  const correctNorm = normalize(correct);
  const distractors = uniq.filter(a => normalize(a)!==correctNorm);
  shuffle(distractors);
  const options = [correct, ...distractors.slice(0,3)];
  shuffle(options);
  return options;
}
function renderMC(){
  const q=currentQ();
  const poolAnswers = QUESTIONS.map(x=>x.antwort).filter(Boolean);
  MC_STATE.options = makeMCOptions(q.antwort, poolAnswers);
  MC_STATE.selected = null;
  mcChoices.innerHTML="";
  MC_STATE.options.forEach((opt,i)=>{
    const id=`mc-${idx}-${i}`;
    const wrap=document.createElement("label");
    wrap.className="choice";
    wrap.innerHTML = `<input type="radio" name="mc" id="${id}" value="${i}"><span>${escapeHtml(opt)}</span>`;
    wrap.querySelector("input").onchange = (e)=>{MC_STATE.selected = Number(e.target.value); mcMsg.textContent="";};
    mcChoices.appendChild(wrap);
  });
  mcMsg.textContent="";
}

// === Wahr/Falsch ===
let TF_STATE={isCorrect:false, proposed:""};
function renderTF(){
  const q=currentQ();
  const poolAnswers = QUESTIONS.map(x=>x.antwort).filter(Boolean);
  // 50% korrekt, sonst falsche Antwort aus Pool
  const coin = Math.random()<0.5;
  if(coin || poolAnswers.length<2){
    TF_STATE.isCorrect=true; TF_STATE.proposed=q.antwort;
  }else{
    let wrong=null, tries=0;
    const target=normalize(q.antwort);
    while(tries<20){
      const cand = poolAnswers[Math.floor(Math.random()*poolAnswers.length)];
      if(normalize(cand)!==target){ wrong=cand; break; }
      tries++;
    }
    TF_STATE.isCorrect=false; TF_STATE.proposed=wrong || (q.antwort+"X");
  }
  tfProposed.textContent = TF_STATE.proposed || "—";
  tfMsg.textContent="";
}

// === Lückentext (ein Wort) ===
let CLOZE_STATE={target:"", masked:""};
function chooseClozeWord(ans){
  const words = (ans||"").split(/\s+/).filter(w=>w.length>=3);
  if(words.length===0) return null;
  return words[Math.floor(Math.random()*words.length)];
}
function maskWordInAnswer(ans, word){
  const re = new RegExp("\\b"+word.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")+"\\b","i");
  return ans.replace(re, "_".repeat(Math.max(3, Math.min(10, word.length))));
}
function renderCloze(){
  const q=currentQ();
  const ans=q.antwort||"";
  const w = chooseClozeWord(ans);
  if(!w){
    CLOZE_STATE.target=""; CLOZE_STATE.masked=ans;
  }else{
    CLOZE_STATE.target=w;
    CLOZE_STATE.masked=maskWordInAnswer(ans, w);
  }
  clozeText.textContent = CLOZE_STATE.masked;
  clozeIn.value=""; clozeMsg.textContent="";
}

// === Buchstaben-Puzzle ===
let LETTERS_STATE={answerNorm:"", slots:[], bank:[]};
function lettersOnly(s){ return (s||"").toLowerCase().replace(/[^a-z0-9äöüß]/g,""); }
function renderLetters(){
  const q=currentQ();
  const ans = lettersOnly(q.antwort);
  LETTERS_STATE.answerNorm = ans;
  // Bank: Antwort-Buchstaben + 2-4 Extra-Zeichen aus anderen Antworten
  let bank = ans.split("");
  const pool = QUESTIONS.map(x=>lettersOnly(x.antwort)).join("");
  const extras = [];
  for(let i=0;i<Math.min(4, Math.max(0, 2+Math.floor(Math.random()*3)));i++){
    const ch = pool.charAt(Math.floor(Math.random()*pool.length)) || "x";
    extras.push(ch);
  }
  bank = bank.concat(extras);
  shuffle(bank);
  LETTERS_STATE.bank = bank;
  LETTERS_STATE.slots = new Array(ans.length).fill("");

  // render slots
  lettersSlots.innerHTML="";
  LETTERS_STATE.slots.forEach((v,i)=>{
    const el=document.createElement("div"); el.className="slot"; el.dataset.idx=i; el.textContent=v||"";
    lettersSlots.appendChild(el);
  });

  // render bank
  lettersBank.innerHTML="";
  LETTERS_STATE.bank.forEach((ch,i)=>{
    const el=document.createElement("button"); el.type="button"; el.className="letter"; el.textContent=ch; el.dataset.ch=ch;
    el.onclick=()=>placeLetter(ch, el);
    lettersBank.appendChild(el);
  });

  lettersMsg.textContent="";
}
function placeLetter(ch, btn){
  const pos = LETTERS_STATE.slots.indexOf("");
  if(pos===-1) return;
  LETTERS_STATE.slots[pos]=ch;
  lettersSlots.children[pos].textContent=ch;
  btn.disabled=true;
}
btnLettersClear.onclick=()=>{
  // reset all
  for(let i=0;i<lettersSlots.children.length;i++){
    lettersSlots.children[i].textContent="";
    LETTERS_STATE.slots[i]="";
  }
  // re-enable all bank buttons
  Array.from(lettersBank.children).forEach(b=>b.disabled=false);
  lettersMsg.textContent="";
};

// timer
function stopTimer(){ if(timerHandle){ clearInterval(timerHandle); timerHandle=null; } timerLeft.classList.add("hidden"); }
function startTimer(){
  stopTimer();
  if(!chkTimer.checked) return;
  timeLeft = Math.max(5, Number(timerSec.value)||20);
  timerLeft.textContent = timeLeft+"s";
  timerLeft.classList.remove("hidden");
  timerHandle = setInterval(()=>{
    timeLeft--;
    timerLeft.textContent = timeLeft+"s";
    if(timeLeft<=0){
      stopTimer();
      // auto "Falsch" verbuchen und weiter
      badCount++; wrongIds.add(currentQ().id); updateStats(); nextQ();
    }
  },1000);
}

// show / update
function showCurrent(resetPerMode=false){
  const q=currentQ();
  qText.innerHTML=escapeHtml(q.frage||"—");
  aText.textContent=q.antwort||"";

  const mode=selMode.value;
  if(mode==="card"){
    aText.hidden=true;
  }else if(mode==="input"){
    if(resetPerMode){ ansIn.value=""; checkMsg.textContent=""; }
  }else if(mode==="mc"){
    renderMC();
  }else if(mode==="tf"){
    renderTF();
  }else if(mode==="cloze"){
    renderCloze();
  }else if(mode==="letters"){
    renderLetters();
  }

  sIdx.textContent=idx+1;
  startTimer();
}
function updateStats(){
  sOk.textContent=okCount;sBad.textContent=badCount;
  barFill.style.width=((idx)/QUESTIONS.length*100).toFixed(1)+"%";
}

// nav basic
btnShow.onclick=()=>{aText.hidden=false; stopTimer();};
btnCorrect.onclick=()=>{okCount++; stopTimer(); nextQ();};
btnWrong.onclick=()=>{badCount++; wrongIds.add(currentQ().id); stopTimer(); nextQ();};
btnPrev.onclick=()=>{ if(idx>0){ idx--; stopTimer(); showCurrent(true); updateStats(); } };
btnNext.onclick=()=>{ stopTimer(); nextQ(); };

function nextQ(){
  if(idx<QUESTIONS.length-1){ idx++; showCurrent(true); updateStats(); }
  else if(chkRelapse.checked && wrongIds.size>0){
    const wrongQs=QUESTIONS.filter(q=>wrongIds.has(q.id));
    QUESTIONS=wrongQs;order=QUESTIONS.map((_,i)=>i);idx=0;wrongIds.clear();
    okCount=0;badCount=0;
    sTot.textContent=QUESTIONS.length;
    showCurrent(true);updateStats();
  }else{
    alert("Fertig!");
  }
}

// Eingabe prüfen
btnCheck.onclick=()=>{
  const q=currentQ();
  const user=ansIn.value;
  const good = normalize(user)===normalize(q.antwort);
  if(good){
    checkMsg.textContent="✔ Richtig"; checkMsg.className="ok";
    okCount++; stopTimer(); nextQ();
  }else{
    checkMsg.textContent="✘ Falsch – "+q.antwort; checkMsg.className="bad";
    badCount++; wrongIds.add(q.id);
  }
  updateStats();
};

// MC prüfen
btnCheckMC.onclick=()=>{
  const radios = mcChoices.querySelectorAll("input[type=radio]");
  let selected=-1; radios.forEach((r,i)=>{ if(r.checked) selected=i; });
  if(selected<0){ mcMsg.textContent="Bitte eine Option wählen."; return; }
  const q=currentQ();
  const chosen = MC_STATE.options[selected];
  const good = normalize(chosen)===normalize(q.antwort);
  if(good){
    mcMsg.textContent="✔ Richtig"; mcMsg.className="ok";
    okCount++; stopTimer(); nextQ();
  }else{
    mcMsg.textContent=`✘ Falsch – richtig ist: ${q.antwort}`; mcMsg.className="bad";
    badCount++; wrongIds.add(q.id);
  }
  updateStats();
};

// TF prüfen
btnTFTrue.onclick=()=>{ gradeTF(true); };
btnTFFalse.onclick=()=>{ gradeTF(false); };
function gradeTF(answerTrue){
  const good = (answerTrue===TF_STATE.isCorrect);
  if(good){
    tfMsg.textContent="✔ Richtig"; tfMsg.className="ok";
    okCount++; stopTimer(); nextQ();
  }else{
    tfMsg.textContent="✘ Falsch"; tfMsg.className="bad";
    badCount++; wrongIds.add(currentQ().id);
  }
  updateStats();
}

// Cloze prüfen
btnClozeCheck.onclick=()=>{
  const user=clozeIn.value;
  const good = normalize(user)===normalize(CLOZE_STATE.target);
  if(good){
    clozeMsg.textContent="✔ Richtig"; clozeMsg.className="ok";
    okCount++; stopTimer(); nextQ();
  }else{
    clozeMsg.textContent=`✘ Falsch – gesucht: ${CLOZE_STATE.target}`; clozeMsg.className="bad";
    badCount++; wrongIds.add(currentQ().id);
  }
  updateStats();
};

// Letters prüfen
btnLettersCheck.onclick=()=>{
  const built = lettersOnly(lettersSlotsAsString());
  const target = LETTERS_STATE.answerNorm;
  const good = built===target && built.length===target.length;
  if(good){
    lettersMsg.textContent="✔ Richtig"; lettersMsg.className="ok";
    okCount++; stopTimer(); nextQ();
  }else{
    lettersMsg.textContent=`✘ Falsch – richtig: ${currentQ().antwort}`; lettersMsg.className="bad";
    badCount++; wrongIds.add(currentQ().id);
  }
  updateStats();
};
function lettersSlotsAsString(){ return Array.from(lettersSlots.children).map(x=>x.textContent||"").join(""); }

// restart
btnRestart.onclick=startSession;

// init
fillCourses();
const q=getQuery();
if(q.course){
  selCourse.value=q.course;fillTopics();
  if(q.all)chkAll.checked=true;
  if(q.topic)selTopic.value=q.topic;
  startSession();
}
</script>
</body>
</html>
